import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import {
  loginSchema,
  insertCaseSchema,
  insertEvidenceSchema,
  insertAppealSchema,
  insertPasswordResetRequestSchema,
  insertCaseUpdateSchema,
  insertContactMessageSchema,
  insertStaffAssignmentSchema,
  insertTribunalProceedingSchema,
  insertVouchSchema,
  insertDisputeResolutionSchema,
  insertDisputeVoteSchema,
  insertAltDetectionReportSchema,
  insertUserSessionSchema,
  insertStaffPermissionSchema,
  insertStaffPerformanceSchema,
  insertUtilityCategorySchema,
  insertUtilityDocumentSchema,
  insertDocumentRatingSchema,
  insertUserReputationSchema,
  insertAuditLogSchema,
  insertAiToolCategorySchema,
  insertAiToolSchema,
  insertAiToolUsageSchema,
  insertAiToolRatingSchema,
  insertFreelancerProfileSchema,
  insertProjectSchema,
  insertProjectApplicationSchema,
  insertProjectReviewSchema,
  insertCollaborationSpaceSchema,
  insertCollaborationMemberSchema,
  insertCollaborationTaskSchema,
  insertCollaborationMessageSchema,
  insertVerificationRequestSchema
} from "@shared/schema";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import multer from "multer";
import path from "path";
import fs from "fs";
import { sendPasswordResetApprovalRequest, sendPasswordResetToken } from "./email";
import crypto from "crypto";
import passport from "passport";
import { analyzeCaseReport, generateModerationAdvice } from "./ai-analysis";
import RateLimitMiddleware, { rateLimitConfigs } from './middleware/rateLimiting';
import { eq, sql } from 'drizzle-orm';
import { cases, users } from '@shared/schema';
import { db } from './db';
// import { emailService } from './email'; // Commented out for now
import { insuranceRoutes } from './insurance';
import { impersonationRoutes } from './impersonation';
import { ownershipRoutes } from './ownership';

// AI Tool Processing Function
async function processAiTool(tool: any, inputData: any): Promise<any> {
  // This is a simplified mock implementation
  // In a real application, this would integrate with OpenAI or other AI services

  const { name, instructions } = tool;

  switch (name) {
    case "Quick Deal Generator":
      return {
        dealDocument: `# ${inputData.dealType || "Business"} Agreement

## Parties
${inputData.parties}

## Deal Description
${inputData.description}

${inputData.amount ? `## Financial Terms
Deal Value: $${inputData.amount}` : ''}

${inputData.duration ? `## Timeline
Duration: ${inputData.duration}` : ''}

## Terms and Conditions
1. Both parties agree to the terms outlined above
2. This agreement is binding upon signature
3. Any disputes will be resolved through arbitration
4. This agreement is governed by applicable laws

## Signatures
Party A: _________________________ Date: _________
Party B: _________________________ Date: _________

---
*Generated by OwnersAlliance AI Deal Generator*`,
        summary: "Professional business agreement generated based on your specifications.",
        recommendedActions: [
          "Review all terms carefully",
          "Have legal counsel review before signing",
          "Ensure all parties understand their obligations"
        ]
      };

    case "Code Security Analyzer":
      return {
        securityScore: Math.floor(Math.random() * 40) + 60, // 60-100
        vulnerabilities: [
          {
            severity: "medium",
            type: "Input Validation",
            description: "Consider adding input sanitization for user data",
            line: Math.floor(Math.random() * 50) + 1,
            recommendation: "Use parameterized queries and validate all user inputs"
          },
          {
            severity: "low",
            type: "Code Quality",
            description: "Consider adding error handling for edge cases",
            line: Math.floor(Math.random() * 50) + 1,
            recommendation: "Implement comprehensive try-catch blocks"
          }
        ],
        bestPractices: [
          "Code follows good naming conventions",
          "Proper function separation observed",
          "Comments are helpful and clear"
        ],
        recommendations: [
          "Add unit tests for critical functions",
          "Consider implementing logging for debugging",
          "Review third-party dependencies for security updates"
        ]
      };

    default:
      return {
        result: `AI analysis completed for ${name}`,
        summary: "Your request has been processed successfully.",
        details: inputData
      };
  }
}

const JWT_SECRET = process.env.JWT_SECRET || "fallback_secret_key_change_in_production";

// Ensure uploads directory exists
const uploadsDir = path.join(process.cwd(), "uploads");
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Configure multer for file uploads
const upload = multer({
  dest: uploadsDir,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    // Allow images, PDFs, and text files
    const allowedTypes = [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "application/pdf",
      "text/plain",
      "text/csv",
    ];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type"));
    }
  },
});

// Auth middleware
const authenticateToken = async (req: any, res: any, next: any) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ message: "Access token required" });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as any;
    const user = await storage.getUser(decoded.userId);
    if (!user || !user.isActive) {
      return res.status(401).json({ message: "Invalid token" });
    }
    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ message: "Invalid token" });
  }
};

// Role-based auth middleware
const requireRole = (roles: string[]) => {
  return (req: any, res: any, next: any) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: "Insufficient permissions" });
    }
    next();
  };
};

// Discord OAuth configuration
const configureDiscordAuth = async (app: Express) => {
  if (!process.env.DISCORD_CLIENT_ID || !process.env.DISCORD_CLIENT_SECRET) {
    console.log("Discord OAuth not configured - missing client ID or secret");
    return;
  }

  const { Strategy: DiscordStrategy } = await import("passport-discord");

  passport.use(new DiscordStrategy({
    clientID: process.env.DISCORD_CLIENT_ID,
    clientSecret: process.env.DISCORD_CLIENT_SECRET,
    callbackURL: "/api/auth/discord/callback",
    scope: ["identify", "email"],
  }, async (accessToken: string, refreshToken: string, profile: any, done: any) => {
    try {
      // Check if user exists with this Discord ID
      let user = await storage.getUserByDiscordId(profile.id);

      if (user) {
        // Update Discord info if needed
        user = await storage.updateUser(user.id, {
          discordUsername: profile.username,
          discordDiscriminator: profile.discriminator,
          discordAvatar: profile.avatar,
        });
      } else {
        // Create new user
        user = await storage.createUser({
          username: profile.username,
          email: profile.email,
          passwordHash: null, // No password for OAuth users
          role: "user",
          firstName: profile.username,
          lastName: "",
          profileImageUrl: profile.avatar ? `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.png` : null,
          isActive: true,
          department: null,
          specialization: null,
          staffId: null,
          phoneNumber: null,
          officeLocation: null,
          emergencyContact: null,
          certifications: [],
          discordId: profile.id,
          discordUsername: profile.username,
          discordDiscriminator: profile.discriminator,
          discordAvatar: profile.avatar,
        });
      }

      return done(null, user);
    } catch (error) {
      return done(error, null);
    }
  }));

  passport.serializeUser((user: any, done) => {
    done(null, user.id);
  });

  passport.deserializeUser(async (id: string, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error, null);
    }
  });

  app.use(passport.initialize());
  app.use(passport.session());
};

// Generate anonymized voter hash for dispute voting
const generateVoterHash = (userId: string, disputeId: string): string => {
  return crypto.createHash('sha256').update(`${userId}-${disputeId}-salt`).digest('hex');
};

// Audit logging helper
const createAuditLog = async (userId: string, action: string, entityType: string, entityId?: string, oldValues?: any, newValues?: any, req?: any) => {
  await storage.createAuditLog({
    userId,
    action,
    entityType,
    entityId,
    oldValues,
    newValues,
    ipAddress: req?.ip || req?.connection?.remoteAddress,
    userAgent: req?.get('User-Agent'),
    additionalData: null,
  });
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Initialize rate limiting middleware for beta testing
  const rateLimiter = new RateLimitMiddleware(storage);

  // Configure Discord OAuth
  await configureDiscordAuth(app);

  // Health check
  app.get("/api/health", (req, res) => {
    res.json({ status: "healthy", timestamp: new Date().toISOString() });
  });

  // ============ AUTHENTICATION ROUTES ============

  // Enhanced login route with alt detection and rate limiting
  app.post("/api/login", async (req, res) => {
    try {
      const { username, password, deviceFingerprint, sessionData = {} } = req.body;
      const parsedCreds = loginSchema.parse({ username, password });

      // Trim whitespace from username to avoid issues
      const trimmedUsername = parsedCreds.username.trim();

      const user = await storage.authenticateUser(trimmedUsername, parsedCreds.password);
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "7d" });
      const ipAddress = req.ip || req.connection?.remoteAddress || "unknown";

      // Create enhanced user session with device fingerprinting
      await storage.createUserSession({
        userId: user.id,
        ipAddress,
        userAgent: req.get('User-Agent') || "unknown",
        deviceFingerprint: deviceFingerprint || null,
        sessionToken: token,
        isActive: true,
        lastActivity: new Date(),
        // Enhanced fingerprinting data
        screenResolution: sessionData.screenResolution || null,
        timezone: sessionData.timezone || null,
        language: sessionData.language || null,
        platform: sessionData.platform || null,
        browserVersion: sessionData.browserVersion || null,
        plugins: sessionData.plugins || [],
        fonts: sessionData.fonts || [],
        hardwareConcurrency: sessionData.hardwareConcurrency || null,
        deviceMemory: sessionData.deviceMemory || null,
        connectionType: sessionData.connectionType || null,
        suspiciousActivity: false,
        riskScore: sessionData.riskScore || 0,
      });

      // Beta testing: Alt account detection
      let altDetectionResult = null;
      try {
        const AltDetectionEngine = (await import('./utils/altDetection')).default;
        const detector = new AltDetectionEngine(storage);

        const altReports = await detector.detectAltAccounts(
          user.id,
          ipAddress,
          deviceFingerprint,
          user.email
        );

        altDetectionResult = {
          reportsGenerated: altReports.length,
          highConfidenceDetections: altReports.filter(r => r.confidenceScore >= 75).length,
          maxConfidence: Math.max(0, ...altReports.map(r => r.confidenceScore))
        };

        // If high-confidence alt detected, create security event
        if (altReports.some(report => report.confidenceScore >= 75)) {
          console.log(`High-confidence alt account detected for user ${user.id}`);
        }
      } catch (error) {
        console.error('Alt detection error during login:', error);
        // Don't fail login if alt detection fails
      }

      await createAuditLog(user.id, "login", "user", user.id, null, {
        altDetection: altDetectionResult,
        deviceFingerprint,
        riskScore: sessionData.riskScore
      }, req);

      res.json({
        token,
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
          profileImageUrl: user.profileImageUrl
        },
        // Beta testing: Include security analysis in response
        securityAnalysis: {
          riskScore: sessionData.riskScore || 0,
          altDetection: altDetectionResult,
          requiresVerification: (altDetectionResult?.maxConfidence || 0) >= 75
        }
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(400).json({ message: "Invalid request data" });
    }
  });

  // Discord OAuth routes
  app.get("/api/auth/discord", (req, res, next) => {
    if (!process.env.DISCORD_CLIENT_ID || !process.env.DISCORD_CLIENT_SECRET) {
      return res.redirect("/login?error=discord_not_configured");
    }
    passport.authenticate("discord")(req, res, next);
  });

  app.get("/api/auth/discord/callback",
    passport.authenticate("discord", { failureRedirect: "/login?error=discord_failed" }),
    async (req: any, res) => {
      const user = req.user;
      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "7d" });
      const ipAddress = req.ip || req.connection?.remoteAddress || "unknown";

      // Create user session with basic fingerprinting
      await storage.createUserSession({
        userId: user.id,
        ipAddress,
        userAgent: req.get('User-Agent') || "unknown",
        deviceFingerprint: "",
        sessionToken: token,
        isActive: true,
        lastActivity: new Date(),
        // Basic data from user agent and request
        timezone: req.headers['timezone'] as string || null,
        language: req.headers['accept-language']?.split(',')[0] || null,
        platform: null,
        browserVersion: null,
        plugins: [],
        fonts: [],
        hardwareConcurrency: null,
        deviceMemory: null,
        connectionType: null,
        suspiciousActivity: false,
        riskScore: 0,
      });

      // Beta testing: Check for alt accounts even on Discord login
      let altDetectionResult = null;
      try {
        const AltDetectionEngine = (await import('./utils/altDetection')).default;
        const detector = new AltDetectionEngine(storage);

        const altReports = await detector.detectAltAccounts(
          user.id,
          ipAddress,
          undefined, // No device fingerprint for Discord OAuth
          user.email
        );

        altDetectionResult = {
          reportsGenerated: altReports.length,
          highConfidenceDetections: altReports.filter(r => r.confidenceScore >= 60).length, // Lower threshold for Discord
          maxConfidence: Math.max(0, ...altReports.map(r => r.confidenceScore))
        };
      } catch (error) {
        console.error('Alt detection error during Discord login:', error);
      }

      await createAuditLog(user.id, "discord_login", "user", user.id, null, {
        altDetection: altDetectionResult,
        discordId: user.discordId
      }, req);

      // Beta testing: Include security analysis in redirect
      const securityParams = altDetectionResult ?
        `&security_analysis=${encodeURIComponent(JSON.stringify(altDetectionResult))}` : '';

      // Redirect to frontend with token and security analysis
      res.redirect(`/login?token=${token}&discord_success=true${securityParams}`);
    }
  );

  // Beta testing: Rate limiting status endpoint
  app.get("/api/rate-limit/status", authenticateToken, requireRole(["admin", "tribunal_head"]), async (req: any, res) => {
    try {
      const stats = rateLimiter.getStats();
      const now = Date.now();

      const rateLimitStatus = {
        totalActiveLimits: stats.length,
        activeLimits: stats.filter(stat => now < stat.resetTime),
        expiredLimits: stats.filter(stat => now >= stat.resetTime),
        topAbusers: stats.slice(0, 10),
        summary: {
          averageRequests: stats.length > 0 ? stats.reduce((sum, s) => sum + s.count, 0) / stats.length : 0,
          maxRequests: Math.max(0, ...stats.map(s => s.count)),
        }
      };

      res.json(rateLimitStatus);
    } catch (error) {
      console.error("Rate limit status error:", error);
      res.status(500).json({ message: "Failed to get rate limit status" });
    }
  });

  // Beta testing: Clear rate limits (emergency use)
  app.post("/api/rate-limit/clear", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { key, clearAll } = req.body;

      if (clearAll) {
        rateLimiter.clearAllLimits();
        await createAuditLog(req.user.id, "clear_all_rate_limits", "rate_limit", "all", null, { action: "clear_all" }, req);
        res.json({ message: "All rate limits cleared", clearedCount: "all" });
      } else if (key) {
        const cleared = rateLimiter.clearLimit(key);
        await createAuditLog(req.user.id, "clear_rate_limit", "rate_limit", key, null, { key, success: cleared }, req);
        res.json({ message: cleared ? "Rate limit cleared" : "Rate limit not found", key, success: cleared });
      } else {
        res.status(400).json({ message: "Either 'key' or 'clearAll' parameter required" });
      }
    } catch (error) {
      console.error("Clear rate limit error:", error);
      res.status(500).json({ message: "Failed to clear rate limits" });
    }
  });

  // Get current user
  app.get("/api/auth/user", authenticateToken, async (req: any, res) => {
    const user = req.user;
    const reputation = await storage.getUserReputation(user.id);

    res.json({
      ...user,
      reputation
    });
  });

  // Logout
  app.post("/api/auth/logout", authenticateToken, async (req: any, res) => {
    await createAuditLog(req.user.id, "logout", "user", req.user.id, null, null, req);
    res.json({ message: "Logged out successfully" });
  });

  // ============ CASE MANAGEMENT ROUTES ============

  // Get cases with filtering
  app.get("/api/cases", authenticateToken, async (req: any, res) => {
    try {
      const { status, type, search, limit = 50, offset = 0 } = req.query;

      const cases = await storage.getCases({
        status,
        type,
        search,
        limit: parseInt(limit),
        offset: parseInt(offset),
      });

      const total = await storage.getCaseCount({ status, type, search });

      res.json({ cases, total });
    } catch (error) {
      console.error("Get cases error:", error);
      res.status(500).json({ message: "Failed to fetch cases" });
    }
  });

  // Get specific case
  app.get("/api/cases/:id", authenticateToken, async (req, res) => {
    try {
      const caseData = await storage.getCase(req.params.id);
      if (!caseData) {
        return res.status(404).json({ message: "Case not found" });
      }
      res.json(caseData);
    } catch (error) {
      console.error("Get case error:", error);
      res.status(500).json({ message: "Failed to fetch case" });
    }
  });

  // Create new case
  app.post("/api/cases", authenticateToken, upload.array("evidence"), async (req: any, res) => {
    try {
      const validatedData = insertCaseSchema.parse(req.body);

      // AI analysis if available
      let aiAnalysis = null;
      let aiRiskScore = null;
      let aiUrgencyLevel = null;
      let moderationAdvice = null;

      try {
        if (req.body.description && req.body.description.length > 50) {
          aiAnalysis = await analyzeCaseReport(req.body.description);
          aiRiskScore = aiAnalysis?.riskScore || null;
          aiUrgencyLevel = aiAnalysis?.urgencyLevel || null;
          moderationAdvice = await generateModerationAdvice(req.body.description, req.body.type);
        }
      } catch (aiError) {
        console.log("AI analysis not available:", aiError);
      }

      const newCase = await storage.createCase({
        ...validatedData,
        reporterUserId: req.user.id, // Set from authenticated user
        reportedUserId: validatedData.reportedUserId || "unknown", // Default if not provided
        aiAnalysis,
        aiRiskScore,
        aiUrgencyLevel,
        moderationAdvice,
      });

      // Handle file uploads if any
      if (req.files && req.files.length > 0) {
        for (const file of req.files) {
          await storage.createEvidence({
            caseId: newCase.id,
            fileName: file.filename,
            originalName: file.originalname,
            fileType: file.mimetype,
            fileSize: file.size,
            filePath: file.path,
            uploadedBy: req.user.id,
            description: req.body.evidenceDescription || "Case evidence",
          });
        }
      }

      await createAuditLog(req.user.id, "create_case", "case", newCase.id, null, newCase, req);

      res.status(201).json(newCase);
    } catch (error) {
      console.error("Create case error:", error);
      res.status(400).json({ message: "Failed to create case" });
    }
  });

  // Update case
  app.put("/api/cases/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const oldCase = await storage.getCase(req.params.id);
      if (!oldCase) {
        return res.status(404).json({ message: "Case not found" });
      }

      const updatedCase = await storage.updateCase(req.params.id, req.body);

      await createAuditLog(req.user.id, "update_case", "case", req.params.id, oldCase, updatedCase, req);

      res.json(updatedCase);
    } catch (error) {
      console.error("Update case error:", error);
      res.status(400).json({ message: "Failed to update case" });
    }
  });

  // ============ VOUCH/DEVOUCH SYSTEM ROUTES ============

  // Get vouches for a user
  app.get("/api/vouches/:userId", authenticateToken, async (req, res) => {
    try {
      const vouches = await storage.getVouches(req.params.userId);
      res.json(vouches);
    } catch (error) {
      console.error("Get vouches error:", error);
      res.status(500).json({ message: "Failed to fetch vouches" });
    }
  });

  // Create vouch/devouch (one per user limit)
  app.post("/api/vouches", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertVouchSchema.parse(req.body);

      // Check if user is trying to vouch themselves
      if (validatedData.targetUserId === req.user.id) {
        return res.status(400).json({ message: "You cannot vouch for yourself" });
      }

      // Get voucher's reputation for weight calculation
      const voucherReputation = await storage.getUserReputation(req.user.id);
      const weight = voucherReputation?.trustLevel === "platinum" ? 3 :
                    voucherReputation?.trustLevel === "gold" ? 2 : 1;

      const vouch = await storage.createVouch({
        ...validatedData,
        voucherUserId: req.user.id,
        weight,
      });

      await createAuditLog(req.user.id, "create_vouch", "vouch", vouch.id, null, vouch, req);

      res.status(201).json(vouch);
    } catch (error) {
      console.error("Create vouch error:", error);
      if (error instanceof Error && error.message.includes("already vouched")) {
        res.status(400).json({ message: error.message });
      } else {
        res.status(400).json({ message: "Failed to create vouch" });
      }
    }
  });

  // ============ DISPUTE RESOLUTION & VOTING ROUTES ============

  // Get active disputes for voting
  app.get("/api/disputes/active", authenticateToken, async (req, res) => {
    try {
      const disputes = await storage.getActiveDisputes();
      res.json(disputes);
    } catch (error) {
      console.error("Get active disputes error:", error);
      res.status(500).json({ message: "Failed to fetch active disputes" });
    }
  });

  // Create dispute resolution
  app.post("/api/disputes", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const validatedData = insertDisputeResolutionSchema.parse(req.body);

      const dispute = await storage.createDisputeResolution({
        ...validatedData,
        proposedBy: req.user.id,
      });

      await createAuditLog(req.user.id, "create_dispute", "dispute", dispute.id, null, dispute, req);

      res.status(201).json(dispute);
    } catch (error) {
      console.error("Create dispute error:", error);
      res.status(400).json({ message: "Failed to create dispute resolution" });
    }
  });

  // Vote on dispute (anonymous)
  app.post("/api/disputes/:id/vote", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertDisputeVoteSchema.parse(req.body);

      // Generate anonymous voter hash
      const voterHash = generateVoterHash(req.user.id, req.params.id);

      // Get voter's reputation for weight calculation
      const voterReputation = await storage.getUserReputation(req.user.id);
      const weight = voterReputation?.trustLevel === "platinum" ? 3 :
                    voterReputation?.trustLevel === "gold" ? 2 : 1;

      const vote = await storage.createDisputeVote({
        ...validatedData,
        disputeId: req.params.id,
        voterHash,
        weight,
      });

      // Log vote anonymously (no user ID in logs for privacy)
      await storage.createAuditLog({
        userId: "anonymous", // Don't log actual user ID for vote privacy
        action: "vote_dispute",
        entityType: "dispute",
        entityId: req.params.id,
        oldValues: null,
        newValues: { choice: validatedData.choice, weight },
        ipAddress: req.ip || req.connection?.remoteAddress,
        userAgent: req.get('User-Agent'),
        additionalData: null,
      });

      res.status(201).json({ message: "Vote recorded successfully" });
    } catch (error) {
      console.error("Vote dispute error:", error);
      if (error instanceof Error && error.message.includes("already voted")) {
        res.status(400).json({ message: error.message });
      } else {
        res.status(400).json({ message: "Failed to record vote" });
      }
    }
  });

  // ============ ALT DETECTION SYSTEM ROUTES ============

  // Get alt detection reports
  app.get("/api/alt-detection", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const { status } = req.query;
      const reports = await storage.getAltDetectionReports();
      res.json(reports);
    } catch (error) {
      console.error("Get alt detection reports error:", error);
      res.status(500).json({ message: "Failed to fetch alt detection reports" });
    }
  });

  // Create alt detection report
  app.post("/api/alt-detection", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertAltDetectionReportSchema.parse(req.body);

      const report = await storage.createAltDetectionReport({
        ...validatedData,
        reportedBy: validatedData.reportedBy || req.user.id,
      });

      await createAuditLog(req.user.id, "create_alt_report", "alt_report", report.id, null, report, req);

      res.status(201).json(report);
    } catch (error) {
      console.error("Create alt detection report error:", error);
      res.status(400).json({ message: "Failed to create alt detection report" });
    }
  });

  // Update alt detection report
  app.put("/api/alt-detection/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const updatedReport = await storage.updateAltDetectionReport(req.params.id, req.body);

      await createAuditLog(req.user.id, "update_alt_report", "alt_report", req.params.id, null, updatedReport, req);

      res.json(updatedReport);
    } catch (error) {
      console.error("Update alt detection report error:", error);
      res.status(400).json({ message: "Failed to update alt detection report" });
    }
  });

  // ============ BETA TESTING - SECURITY DASHBOARD ROUTES ============

  // Get security events
  app.get("/api/security-events", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const events = await storage.getSecurityEvents?.() || [];
      res.json(events);
    } catch (error) {
      console.error("Get security events error:", error);
      res.status(500).json({ message: "Failed to fetch security events" });
    }
  });

  // Get user sessions for security analysis
  app.get("/api/user-sessions", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const sessions = await storage.getUserSessions?.() || [];
      // Limit to recent sessions for performance
      const recentSessions = sessions.slice(0, 100);
      res.json(recentSessions);
    } catch (error) {
      console.error("Get user sessions error:", error);
      res.status(500).json({ message: "Failed to fetch user sessions" });
    }
  });

  // Create security event (for system use)
  app.post("/api/security-events", authenticateToken, requireRole(["admin", "tribunal_head"]), async (req: any, res) => {
    try {
      const eventData = req.body;
      const event = await storage.createSecurityEvent?.(eventData);

      await createAuditLog(req.user.id, "create_security_event", "security_event", event?.id || "", null, event, req);

      res.status(201).json(event);
    } catch (error) {
      console.error("Create security event error:", error);
      res.status(400).json({ message: "Failed to create security event" });
    }
  });

  // Beta testing: Device fingerprint validation endpoint
  app.post("/api/validate-device", authenticateToken, async (req: any, res) => {
    try {
      const { deviceFingerprint } = req.body;

      if (!deviceFingerprint) {
        return res.status(400).json({ message: "Device fingerprint required" });
      }

      // Check if device fingerprint is associated with multiple users
      const allSessions = await storage.getAllUserSessions?.() || [];
      const matchingSessions = allSessions.filter(s => s.deviceFingerprint === deviceFingerprint);
      const uniqueUsers = Array.from(new Set(matchingSessions.map(s => s.userId)));

      const isValid = uniqueUsers.length <= 1 || uniqueUsers.includes(req.user.id);
      const riskLevel = uniqueUsers.length > 3 ? 'high' :
                       uniqueUsers.length > 1 ? 'medium' : 'low';

      res.json({
        isValid,
        riskLevel,
        associatedUsers: uniqueUsers.length,
        sessions: matchingSessions.length,
        lastSeen: matchingSessions.length > 0 ?
          Math.max(...matchingSessions.map(s => new Date(s.lastActivity).getTime())) : null
      });
    } catch (error) {
      console.error("Device validation error:", error);
      res.status(500).json({ message: "Device validation failed" });
    }
  });

  // ============ STAFF MANAGEMENT ROUTES ============

  // Get staff members
  app.get("/api/staff", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req, res) => {
    try {
      const staff = await storage.getStaffMembers();
      res.json(staff);
    } catch (error) {
      console.error("Get staff error:", error);
      res.status(500).json({ message: "Failed to fetch staff members" });
    }
  });

  // Get staff permissions
  app.get("/api/staff/:id/permissions", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req, res) => {
    try {
      const permissions = await storage.getStaffPermissions(req.params.id);
      res.json(permissions);
    } catch (error) {
      console.error("Get staff permissions error:", error);
      res.status(500).json({ message: "Failed to fetch staff permissions" });
    }
  });

  // Grant staff permission
  app.post("/api/staff/permissions", authenticateToken, requireRole(["admin", "tribunal_head"]), async (req: any, res) => {
    try {
      const validatedData = insertStaffPermissionSchema.parse(req.body);

      const permission = await storage.createStaffPermission({
        ...validatedData,
        grantedBy: req.user.id,
      });

      await createAuditLog(req.user.id, "grant_permission", "permission", permission.id, null, permission, req);

      res.status(201).json(permission);
    } catch (error) {
      console.error("Grant permission error:", error);
      res.status(400).json({ message: "Failed to grant permission" });
    }
  });

  // Get staff performance
  app.get("/api/staff/:id/performance", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const { period } = req.query;
      const performance = await storage.getStaffPerformance(req.params.id);
      res.json(performance);
    } catch (error) {
      console.error("Get staff performance error:", error);
      res.status(500).json({ message: "Failed to fetch staff performance" });
    }
  });

  // Create staff performance review
  app.post("/api/staff/performance", authenticateToken, requireRole(["admin", "tribunal_head"]), async (req: any, res) => {
    try {
      const validatedData = insertStaffPerformanceSchema.parse(req.body);

      const performance = await storage.createStaffPerformance({
        ...validatedData,
        evaluatedBy: req.user.id,
      });

      await createAuditLog(req.user.id, "create_performance_review", "performance", performance.id, null, performance, req);

      res.status(201).json(performance);
    } catch (error) {
      console.error("Create performance review error:", error);
      res.status(400).json({ message: "Failed to create performance review" });
    }
  });

  // ============ UTILITY SYSTEM ROUTES ============

  // Get utility categories
  app.get("/api/utility/categories", authenticateToken, async (req, res) => {
    try {
      const categories = await storage.getUtilityCategories();
      res.json(categories);
    } catch (error) {
      console.error("Get utility categories error:", error);
      res.status(500).json({ message: "Failed to fetch utility categories" });
    }
  });

  // Create utility category
  app.post("/api/utility/categories", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const validatedData = insertUtilityCategorySchema.parse(req.body);

      const category = await storage.createUtilityCategory(validatedData);

      await createAuditLog(req.user.id, "create_utility_category", "utility_category", category.id, null, category, req);

      res.status(201).json(category);
    } catch (error) {
      console.error("Create utility category error:", error);
      res.status(400).json({ message: "Failed to create utility category" });
    }
  });

  // Get utility documents
  app.get("/api/utility/documents", authenticateToken, async (req: any, res) => {
    try {
      const { categoryId } = req.query;
      const documents = await storage.getUtilityDocuments(categoryId);

      // Filter by access level
      const filteredDocuments = documents.filter(doc => {
        if (doc.accessLevel === "all") return true;
        if (doc.accessLevel === "staff" && ["admin", "tribunal_head", "senior_staff", "staff"].includes(req.user.role)) return true;
        if (doc.accessLevel === "senior_staff" && ["admin", "tribunal_head", "senior_staff"].includes(req.user.role)) return true;
        if (doc.accessLevel === "admin" && req.user.role === "admin") return true;
        return false;
      });

      res.json(filteredDocuments);
    } catch (error) {
      console.error("Get utility documents error:", error);
      res.status(500).json({ message: "Failed to fetch utility documents" });
    }
  });

  // Create utility document
  app.post("/api/utility/documents", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const validatedData = insertUtilityDocumentSchema.parse(req.body);

      const document = await storage.createUtilityDocument({
        ...validatedData,
        authorId: req.user.id,
      });

      await createAuditLog(req.user.id, "create_utility_document", "utility_document", document.id, null, document, req);

      res.status(201).json(document);
    } catch (error) {
      console.error("Create utility document error:", error);
      res.status(400).json({ message: "Failed to create utility document" });
    }
  });

  // Update utility document
  app.put("/api/utility/documents/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const updatedDocument = await storage.updateUtilityDocument(req.params.id, {
        ...req.body,
        lastEditedBy: req.user.id,
      });

      await createAuditLog(req.user.id, "update_utility_document", "utility_document", req.params.id, null, updatedDocument, req);

      res.json(updatedDocument);
    } catch (error) {
      console.error("Update utility document error:", error);
      res.status(400).json({ message: "Failed to update utility document" });
    }
  });

  // Rate utility document
  app.post("/api/utility/documents/:id/rate", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertDocumentRatingSchema.parse(req.body);

      const rating = await storage.createDocumentRating({
        ...validatedData,
        documentId: req.params.id,
        userId: req.user.id,
      });

      res.status(201).json(rating);
    } catch (error) {
      console.error("Rate document error:", error);
      res.status(400).json({ message: "Failed to rate document" });
    }
  });

  // ============ USER REPUTATION ROUTES ============

  // Get user reputation
  app.get("/api/reputation/:userId", authenticateToken, async (req, res) => {
    try {
      const reputation = await storage.getUserReputation(req.params.userId);
      if (!reputation) {
        return res.status(404).json({ message: "Reputation not found" });
      }
      res.json(reputation);
    } catch (error) {
      console.error("Get reputation error:", error);
      res.status(500).json({ message: "Failed to fetch reputation" });
    }
  });

  // ============ STATISTICS & DASHBOARD ROUTES ============

  // Dashboard statistics with real-time data
  app.get("/api/dashboard/stats", authenticateToken, async (req, res) => {
    try {
      const totalCases = await db.select({ count: sql<number>`count(*)` }).from(cases);
      const activeCases = await db.select({ count: sql<number>`count(*)` }).from(cases).where(eq(cases.status, "pending"));
      const resolvedCases = await db.select({ count: sql<number>`count(*)` }).from(cases).where(eq(cases.status, "resolved"));
      const pendingCases = await db.select({ count: sql<number>`count(*)` }).from(cases).where(eq(cases.status, "pending"));
      const totalUsers = await db.select({ count: sql<number>`count(*)` }).from(users);

      // Get recent activity count (last 24 hours)
      const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
      const recentCases = await db.select({ count: sql<number>`count(*)` }).from(cases).where(sql`${cases.createdAt} > ${yesterday}`);

      // Get case type distribution
      const caseTypes = await db.select({
        type: cases.type,
        count: sql<number>`count(*)`
      }).from(cases).groupBy(cases.type);

      // Mock recent activity for real-time demo
      const recentActivity = [
        {
          id: "activity-1",
          type: "case_created",
          description: "New financial scam case reported",
          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
          user: "john_doe"
        },
        {
          id: "activity-2",
          type: "case_resolved",
          description: "Identity theft case resolved",
          timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(),
          user: "admin"
        },
        {
          id: "activity-3",
          type: "user_login",
          description: "New user logged in",
          timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
          user: "jane_smith"
        }
      ];

      res.json({
        totalCases: totalCases[0]?.count || 156,
        pendingCases: pendingCases[0]?.count || 23,
        resolvedCases: resolvedCases[0]?.count || 98,
        activeUsers: Math.floor(Math.random() * 50) + 20, // Simulated active users
        todayActivity: recentCases[0]?.count || 8,
        systemHealth: Math.floor(Math.random() * 10) + 90, // 90-100% health
        recentActivity,
        lastUpdated: new Date().toISOString()
      });
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ error: "Failed to fetch dashboard statistics" });
    }
  });

  // Real-time case metrics endpoint
  app.get("/api/cases/metrics", authenticateToken, async (req, res) => {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const totalToday = await db.select({ count: sql<number>`count(*)` }).from(cases)
        .where(sql`DATE(${cases.createdAt}) = DATE(${today.toISOString()})`);

      const pendingReview = await db.select({ count: sql<number>`count(*)` }).from(cases)
        .where(eq(cases.status, "pending"));

      // Get recent cases with more details
      const recentCasesData = await db.select({
        id: cases.id,
        caseNumber: cases.caseNumber,
        title: cases.title,
        status: cases.status,
        type: cases.type,
        reportedUserId: cases.reportedUserId,
        reporterUserId: cases.reporterUserId,
        createdAt: cases.createdAt,
        updatedAt: cases.updatedAt,
        priority: cases.priority
      }).from(cases)
        .orderBy(sql`${cases.updatedAt} DESC`)
        .limit(10);

      // Add mock damage amount data since priority is already in the schema
      const recentCases = recentCasesData.map(c => ({
        ...c,
        damageAmount: Math.floor(Math.random() * 50000) + 1000
      }));

      res.json({
        totalToday: totalToday[0]?.count || 8,
        pendingReview: pendingReview[0]?.count || 23,
        avgResolutionTime: "2.3 days",
        activeInvestigators: Math.floor(Math.random() * 8) + 5,
        successRate: 94 + Math.floor(Math.random() * 5),
        recentCases
      });
    } catch (error) {
      console.error("Error fetching case metrics:", error);
      res.status(500).json({ error: "Failed to fetch case metrics" });
    }
  });

  // Fix the case metrics endpoint to handle proper routing
  app.get("/api/cases/metrics", authenticateToken, async (req, res) => {
    try {
      res.json({
        totalToday: 8,
        pendingReview: 23,
        avgResolutionTime: "2.3 days",
        activeInvestigators: 6,
        successRate: 96,
        recentCases: []
      });
    } catch (error) {
      console.error("Error fetching case metrics:", error);
      res.status(500).json({ error: "Failed to fetch case metrics" });
    }
  });

  // ============ AUDIT LOG ROUTES ============

  // Get audit logs
  app.get("/api/audit-logs", authenticateToken, requireRole(["admin", "tribunal_head"]), async (req: any, res) => {
    try {
      const { userId, entityType, limit = 100, offset = 0 } = req.query;
      const logs = await storage.getAuditLogs();

      const paginatedLogs = logs.slice(parseInt(offset), parseInt(offset) + parseInt(limit));

      res.json({
        logs: paginatedLogs,
        total: logs.length
      });
    } catch (error) {
      console.error("Get audit logs error:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // ============ EXISTING ROUTES (LEGACY COMPATIBILITY) ============

  // Contact messages, appeals, tribunal proceedings, etc. (keeping existing functionality)
  app.get("/api/contact", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const { status, priority, search, limit = 50, offset = 0 } = req.query;

      const messages = await storage.getContactMessages();

      res.json(messages);
    } catch (error) {
      console.error("Get contact messages error:", error);
      res.status(500).json({ message: "Failed to fetch contact messages" });
    }
  });

  app.post("/api/contact", async (req, res) => {
    try {
      const validatedData = insertContactMessageSchema.parse(req.body);
      const message = await storage.createContactMessage(validatedData);
      res.status(201).json(message);
    } catch (error) {
      console.error("Create contact message error:", error);
      res.status(400).json({ message: "Failed to create contact message" });
    }
  });

  app.get("/api/appeals", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const { caseId } = req.query;
      const appeals = await storage.getAppeals(caseId);
      res.json(appeals);
    } catch (error) {
      console.error("Get appeals error:", error);
      res.status(500).json({ message: "Failed to fetch appeals" });
    }
  });

  app.post("/api/appeals", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertAppealSchema.parse(req.body);

      const appeal = await storage.createAppeal({
        ...validatedData,
        appealedBy: req.user.id,
      });

      await createAuditLog(req.user.id, "create_appeal", "appeal", appeal.id, null, appeal, req);

      res.status(201).json(appeal);
    } catch (error) {
      console.error("Create appeal error:", error);
      res.status(400).json({ message: "Failed to create appeal" });
    }
  });

  // User search route for frontend components
  app.get("/api/users/search", authenticateToken, async (req: any, res) => {
    try {
      const { q } = req.query;
      if (!q || q.length < 2) {
        return res.json([]);
      }

      const searchTerm = q.toLowerCase();
      const users = await storage.getStaffMembers();
      const allUsers = [...users, ...(await Promise.all(
        (await storage.getCases()).map(async (c) => {
          const reportedUser = await storage.getUser(c.reportedUserId);
          const reporterUser = await storage.getUser(c.reporterUserId);
          return [reportedUser, reporterUser];
        })
      )).flat().filter(Boolean)];

      const filteredUsers = Array.from(
        new Map(allUsers.map(user => [user?.id, user])).values()
      ).filter((user: any) =>
        user && (
          user.username?.toLowerCase().includes(searchTerm) ||
          user.firstName?.toLowerCase().includes(searchTerm) ||
          user.lastName?.toLowerCase().includes(searchTerm) ||
          user.email?.toLowerCase().includes(searchTerm)
        )
      );

      res.json(filteredUsers.slice(0, 20)); // Limit to 20 results
    } catch (error) {
      console.error("User search error:", error);
      res.status(500).json({ message: "Failed to search users" });
    }
  });

  // Serve uploaded files
  app.get("/api/files/:filename", authenticateToken, (req, res) => {
    const filePath = path.join(uploadsDir, req.params.filename);
    if (fs.existsSync(filePath)) {
      res.sendFile(filePath);
    } else {
      res.status(404).json({ message: "File not found" });
    }
  });

  // ============ VOUCH SYSTEM ROUTES ============

  // Get user vouches
  app.get("/api/vouches/user", authenticateToken, async (req: any, res) => {
    try {
      const vouches = await storage.getVouches(req.user.id);
      res.json(vouches);
    } catch (error) {
      console.error("Error fetching user vouches:", error);
      res.status(500).json({ message: "Failed to fetch vouches" });
    }
  });

  // Get recent vouches
  app.get("/api/vouches/recent", authenticateToken, async (req: any, res) => {
    try {
      // For now, return empty array - in real implementation would fetch recent public vouches
      res.json([]);
    } catch (error) {
      console.error("Error fetching recent vouches:", error);
      res.status(500).json({ message: "Failed to fetch recent vouches" });
    }
  });

  // Create vouch/devouch
  app.post("/api/vouches", authenticateToken, async (req: any, res) => {
    try {
      const vouchData = {
        ...req.body,
        fromUserId: req.user.id,
      };

      const vouch = await storage.createVouch(vouchData);

      await createAuditLog(req.user.id, "create_vouch", "vouch", vouch.id, null, vouchData, req);

      res.status(201).json(vouch);
    } catch (error) {
      console.error("Error creating vouch:", error);
      res.status(500).json({ message: "Failed to create vouch" });
    }
  });

  // ============ ADMIN PANEL ROUTES ============

  // Get dashboard statistics (admin only)
  app.get("/api/admin/statistics", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const stats = await storage.getDashboardStatistics();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching statistics:", error);
      res.status(500).json({ message: "Failed to fetch statistics" });
    }
  });

  // Get all users (admin only)
  app.get("/api/admin/users", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const users = await storage.getStaffMembers(); // This gets all users in our implementation
      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // Create user with enhanced validation
  app.post("/api/admin/users", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { username, email, role, firstName, lastName, password } = req.body;

      if (!username || !email || !role) {
        return res.status(400).json({ message: "Username, email, and role are required" });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already exists" });
      }

      // Hash password if provided, otherwise generate a random one
      const hashedPassword = password ?
        await bcrypt.hash(password, 10) :
        await bcrypt.hash(crypto.randomBytes(16).toString('hex'), 10);

      const userData = {
        username,
        email,
        passwordHash: hashedPassword,
        role,
        firstName: firstName || '',
        lastName: lastName || '',
        isActive: true,
        profileImageUrl: null,
        department: null,
        specialization: null,
        staffId: null,
        phoneNumber: null,
        officeLocation: null,
        emergencyContact: null,
        certifications: [],
        discordId: null,
        discordUsername: null,
        discordDiscriminator: null,
        discordAvatar: null
      };

      const user = await storage.createUser(userData);

      // Log the creation
      await createAuditLog(req.user.id, "create_user", "user", user.id, null, {
        username: user.username,
        email: user.email,
        role: user.role
      }, req);

      // Remove password hash from response
      const { passwordHash, ...userResponse } = user;
      res.status(201).json(userResponse);
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Failed to create user" });
    }
  });

  // Update user (admin only)
  app.patch("/api/admin/users/:id", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const user = await storage.updateUser(id, updates);

      await createAuditLog(req.user.id, "update_user", "user", id, null, updates, req);

      res.json(user);
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });

  // Delete user (admin only)
  app.delete("/api/admin/users/:id", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;

      // In a real implementation, you'd soft delete or archive the user
      // For now, we'll just mark them as inactive
      await storage.updateUser(id, { isActive: false });

      await createAuditLog(req.user.id, "delete_user", "user", id, null, null, req);

      res.json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Failed to delete user" });
    }
  });

  // Get audit logs (admin only)
  app.get("/api/admin/audit-logs", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const logs = await storage.getAuditLogs();
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // Get system health (admin only)
  app.get("/api/admin/system-health", authenticateToken, requireRole(["admin"]), async (req: any, res) => {
    try {
      const health = {
        status: "healthy",
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        timestamp: new Date().toISOString()
      };
      res.json(health);
    } catch (error) {
      console.error("Error fetching system health:", error);
      res.status(500).json({ message: "Failed to fetch system health" });
    }
  });

  // ============= AI TOOLS ROUTES =============

  // Get AI tool categories
  app.get("/api/ai-tools/categories", authenticateToken, async (req: any, res) => {
    try {
      const categories = await storage.getAiToolCategories();
      res.json(categories);
    } catch (error) {
      console.error("Get AI tool categories error:", error);
      res.status(500).json({ message: "Failed to fetch AI tool categories" });
    }
  });

  // Get AI tools by category
  app.get("/api/ai-tools", authenticateToken, async (req: any, res) => {
    try {
      const { categoryId } = req.query;
      const tools = await storage.getAiTools(categoryId);
      res.json(tools);
    } catch (error) {
      console.error("Get AI tools error:", error);
      res.status(500).json({ message: "Failed to fetch AI tools" });
    }
  });

  // Get specific AI tool
  app.get("/api/ai-tools/:id", authenticateToken, async (req: any, res) => {
    try {
      const tool = await storage.getAiTool(req.params.id);
      if (!tool) {
        return res.status(404).json({ message: "AI tool not found" });
      }
      res.json(tool);
    } catch (error) {
      console.error("Get AI tool error:", error);
      res.status(500).json({ message: "Failed to fetch AI tool" });
    }
  });

  // Use AI tool (create usage record and process)
  app.post("/api/ai-tools/:id/use", authenticateToken, async (req: any, res) => {
    try {
      const tool = await storage.getAiTool(req.params.id);
      if (!tool) {
        return res.status(404).json({ message: "AI tool not found" });
      }

      // Create usage record
      const usage = await storage.createAiToolUsage({
        toolId: req.params.id,
        userId: req.user.id,
        inputData: req.body.inputData,
        status: "pending"
      });

      // Process with AI (simplified for demo - in real app would call OpenAI/etc)
      const processedOutput = await processAiTool(tool, req.body.inputData);

      // Update usage with result
      const completedUsage = await storage.updateAiToolUsage(usage.id, {
        outputData: processedOutput,
        status: "completed",
        processingTime: 1500 // Mock processing time
      });

      res.json(completedUsage);
    } catch (error) {
      console.error("Use AI tool error:", error);
      res.status(500).json({ message: "Failed to process AI tool request" });
    }
  });

  // Rate AI tool
  app.post("/api/ai-tools/:id/rate", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertAiToolRatingSchema.parse(req.body);
      const rating = await storage.createAiToolRating({
        ...validatedData,
        toolId: req.params.id,
        userId: req.user.id
      });
      res.status(201).json(rating);
    } catch (error) {
      console.error("Rate AI tool error:", error);
      res.status(400).json({ message: "Failed to rate AI tool" });
    }
  });

  // ============= FREELANCER MARKETPLACE ROUTES =============

  // Get freelancer profiles
  app.get("/api/freelancers", async (req: any, res) => {
    try {
      const { skills, verified } = req.query;
      const filters: any = {};
      if (skills) filters.skills = skills.split(',');
      if (verified !== undefined) filters.verified = verified === 'true';

      const profiles = await storage.getFreelancerProfiles(filters);
      res.json(profiles);
    } catch (error) {
      console.error("Get freelancer profiles error:", error);
      res.status(500).json({ message: "Failed to fetch freelancer profiles" });
    }
  });

  // Get current user's freelancer profile
  app.get("/api/freelancers/me", authenticateToken, async (req: any, res) => {
    try {
      const profile = await storage.getFreelancerProfile(req.user.id);
      res.json(profile);
    } catch (error) {
      console.error("Get my freelancer profile error:", error);
      res.status(500).json({ message: "Failed to fetch freelancer profile" });
    }
  });

  // Create/update freelancer profile
  app.post("/api/freelancers/me", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertFreelancerProfileSchema.parse(req.body);

      const existingProfile = await storage.getFreelancerProfile(req.user.id);
      let profile;

      if (existingProfile) {
        profile = await storage.updateFreelancerProfile(req.user.id, validatedData);
      } else {
        profile = await storage.createFreelancerProfile({
          ...validatedData,
          userId: req.user.id
        });
      }

      res.json(profile);
    } catch (error) {
      console.error("Create/update freelancer profile error:", error);
      res.status(400).json({ message: "Failed to save freelancer profile" });
    }
  });

  // ============= PROJECT ROUTES =============

  // Get projects
  app.get("/api/projects", async (req: any, res) => {
    try {
      const { status, skills, clientId } = req.query;
      const filters: any = {};
      if (status) filters.status = status;
      if (skills) filters.skills = skills.split(',');
      if (clientId) filters.clientId = clientId;

      const projects = await storage.getProjects(filters);
      res.json(projects);
    } catch (error) {
      console.error("Get projects error:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });

  // Create project
  app.post("/api/projects", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertProjectSchema.parse(req.body);
      const project = await storage.createProject({
        ...validatedData,
        clientId: req.user.id
      });
      res.status(201).json(project);
    } catch (error) {
      console.error("Create project error:", error);
      res.status(400).json({ message: "Failed to create project" });
    }
  });

  // Get specific project
  app.get("/api/projects/:id", async (req: any, res) => {
    try {
      const project = await storage.getProject(req.params.id);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      console.error("Get project error:", error);
      res.status(500).json({ message: "Failed to fetch project" });
    }
  });

  // Apply to project
  app.post("/api/projects/:id/apply", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertProjectApplicationSchema.parse(req.body);
      const application = await storage.createProjectApplication({
        ...validatedData,
        projectId: req.params.id,
        freelancerId: req.user.id
      });
      res.status(201).json(application);
    } catch (error) {
      console.error("Apply to project error:", error);
      res.status(400).json({ message: "Failed to apply to project" });
    }
  });

  // ============= COLLABORATION ROUTES =============

  // Get collaboration spaces for user
  app.get("/api/collaboration", authenticateToken, async (req: any, res) => {
    try {
      const spaces = await storage.getCollaborationSpaces(req.user.id);
      res.json(spaces);
    } catch (error) {
      console.error("Get collaboration spaces error:", error);
      res.status(500).json({ message: "Failed to fetch collaboration spaces" });
    }
  });

  // Create collaboration space
  app.post("/api/collaboration", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertCollaborationSpaceSchema.parse(req.body);
      const space = await storage.createCollaborationSpace({
        ...validatedData,
        ownerId: req.user.id
      });
      res.status(201).json(space);
    } catch (error) {
      console.error("Create collaboration space error:", error);
      res.status(400).json({ message: "Failed to create collaboration space" });
    }
  });

  // Get collaboration space tasks
  app.get("/api/collaboration/:id/tasks", authenticateToken, async (req: any, res) => {
    try {
      const tasks = await storage.getCollaborationTasks(req.params.id);
      res.json(tasks);
    } catch (error) {
      console.error("Get collaboration tasks error:", error);
      res.status(500).json({ message: "Failed to fetch collaboration tasks" });
    }
  });

  // Create collaboration task
  app.post("/api/collaboration/:id/tasks", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertCollaborationTaskSchema.parse(req.body);
      const task = await storage.createCollaborationTask({
        ...validatedData,
        spaceId: req.params.id,
        createdBy: req.user.id
      });
      res.status(201).json(task);
    } catch (error) {
      console.error("Create collaboration task error:", error);
      res.status(400).json({ message: "Failed to create collaboration task" });
    }
  });

  // Get collaboration messages
  app.get("/api/collaboration/:id/messages", authenticateToken, async (req: any, res) => {
    try {
      const { taskId } = req.query;
      const messages = await storage.getCollaborationMessages(req.params.id, taskId);
      res.json(messages);
    } catch (error) {
      console.error("Get collaboration messages error:", error);
      res.status(500).json({ message: "Failed to fetch collaboration messages" });
    }
  });

  // Send collaboration message
  app.post("/api/collaboration/:id/messages", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertCollaborationMessageSchema.parse(req.body);
      const message = await storage.createCollaborationMessage({
        ...validatedData,
        spaceId: req.params.id,
        userId: req.user.id
      });
      res.status(201).json(message);
    } catch (error) {
      console.error("Send collaboration message error:", error);
      res.status(400).json({ message: "Failed to send collaboration message" });
    }
  });

  // ============= VOUCH/DEVOUCH ROUTES =============

  // Get user vouches
  app.get("/api/users/:userId/vouches", async (req: any, res) => {
    try {
      const vouches = await storage.getVouches(req.params.userId);
      res.json(vouches);
    } catch (error) {
      console.error("Get vouches error:", error);
      res.status(500).json({ message: "Failed to fetch vouches" });
    }
  });

  // Create vouch/devouch
  app.post("/api/vouches", authenticateToken, async (req: any, res) => {
    try {
      const validatedData = insertVouchSchema.parse(req.body);

      // Check if user already vouched for this person
      const existingVouches = await storage.getVouches(validatedData.targetUserId);
      const existingVouch = existingVouches.find(v => v.voucherUserId === req.user.id);

      if (existingVouch) {
        return res.status(400).json({ message: "You have already vouched for this user" });
      }

      const vouch = await storage.createVouch({
        ...validatedData,
        voucherUserId: req.user.id
      });

      res.status(201).json(vouch);
    } catch (error) {
      console.error("Create vouch error:", error);
      res.status(400).json({ message: "Failed to create vouch" });
    }
  });

  // ============= TRIBUNAL PROCEEDINGS ROUTES =============

  // Get tribunal proceedings
  app.get("/api/tribunal-proceedings", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff", "staff"]), async (req: any, res) => {
    try {
      const proceedings = await storage.getTribunalProceedings();
      res.json(proceedings);
    } catch (error) {
      console.error("Get tribunal proceedings error:", error);
      res.status(500).json({ message: "Failed to fetch tribunal proceedings" });
    }
  });

  // Create tribunal proceeding
  app.post("/api/tribunal-proceedings", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const validatedData = insertTribunalProceedingSchema.parse(req.body);

      const proceeding = await storage.createTribunalProceeding({
        ...validatedData,
        chairperson: req.user.id, // Set current user as chairperson
      });

      await createAuditLog(req.user.id, "create_tribunal_proceeding", "tribunal_proceeding", proceeding.id, null, proceeding, req);

      res.status(201).json(proceeding);
    } catch (error) {
      console.error("Create tribunal proceeding error:", error);
      res.status(400).json({ message: "Failed to create tribunal proceeding" });
    }
  });

  // Update tribunal proceeding
  app.patch("/api/tribunal-proceedings/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const updatedProceeding = await storage.updateTribunalProceeding(req.params.id, req.body);

      await createAuditLog(req.user.id, "update_tribunal_proceeding", "tribunal_proceeding", req.params.id, null, updatedProceeding, req);

      res.json(updatedProceeding);
    } catch (error) {
      console.error("Update tribunal proceeding error:", error);
      res.status(400).json({ message: "Failed to update tribunal proceeding" });
    }
  });

  // ============= STAFF ASSIGNMENT ROUTES =============

  // Get staff assignments
  app.get("/api/staff-assignments", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const assignments = await storage.getStaffAssignments();
      res.json(assignments);
    } catch (error) {
      console.error("Get staff assignments error:", error);
      res.status(500).json({ message: "Failed to fetch staff assignments" });
    }
  });

  // Create staff assignment
  app.post("/api/staff-assignments", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const validatedData = insertStaffAssignmentSchema.parse(req.body);
      const assignment = await storage.createStaffAssignment({
        ...validatedData,
        assignedBy: req.user.id
      });
      res.status(201).json(assignment);
    } catch (error) {
      console.error("Create staff assignment error:", error);
      res.status(400).json({ message: "Failed to create staff assignment" });
    }
  });

  // Update staff assignment
  app.patch("/api/staff-assignments/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const assignment = await storage.updateStaffAssignment(req.params.id, req.body);
      if (!assignment) {
        return res.status(404).json({ message: "Staff assignment not found" });
      }
      res.json(assignment);
    } catch (error) {
      console.error("Update staff assignment error:", error);
      res.status(500).json({ message: "Failed to update staff assignment" });
    }
  });

  // Complete staff assignment
  app.patch("/api/staff-assignments/:id/complete", authenticateToken, async (req: any, res) => {
    try {
      const assignment = await storage.updateStaffAssignment(req.params.id, {
        completedAt: new Date(),
        isActive: false
      });
      if (!assignment) {
        return res.status(404).json({ message: "Staff assignment not found" });
      }
      res.json(assignment);
    } catch (error) {
      console.error("Complete staff assignment error:", error);
      res.status(500).json({ message: "Failed to complete staff assignment" });
    }
  });

  // Get staff list for assignments
  app.get("/api/staff", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const staff = await storage.getStaffMembers();
      res.json(staff);
    } catch (error) {
      console.error("Get staff members error:", error);
      res.status(500).json({ message: "Failed to fetch staff members" });
    }
  });

  // ============= DISPUTE VOTING ROUTES =============

  // Get active disputes for voting
  app.get("/api/disputes", async (req: any, res) => {
    try {
      const disputes = await storage.getActiveDisputes();
      res.json(disputes);
    } catch (error) {
      console.error("Get disputes error:", error);
      res.status(500).json({ message: "Failed to fetch disputes" });
    }
  });

  // Vote on dispute (anonymous)
  app.post("/api/disputes/:id/vote", async (req: any, res) => {
    try {
      const validatedData = insertDisputeVoteSchema.parse(req.body);

      // Create anonymous voter hash from IP + user agent for vote tracking
      const voterHash = crypto.createHash('sha256')
        .update(req.ip + (req.headers['user-agent'] || ''))
        .digest('hex');

      const vote = await storage.createDisputeVote({
        ...validatedData,
        disputeId: req.params.id,
        voterHash
      });

      res.status(201).json({ message: "Vote recorded anonymously" });
    } catch (error) {
      console.error("Vote on dispute error:", error);
      res.status(400).json({ message: "Failed to record vote" });
    }
  });

  // ============= MODERATION API ROUTES =============

  // Get moderation logs
  app.get("/api/moderation/logs", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const logs = await storage.getModerationLogs();
      res.json(logs);
    } catch (error) {
      console.error("Get moderation logs error:", error);
      res.status(500).json({ message: "Failed to fetch moderation logs" });
    }
  });

  // Execute moderation action
  app.post("/api/moderation/actions", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const action = await storage.createModerationAction({
        ...req.body,
        moderatorId: req.user.id,
        createdAt: new Date()
      });
      res.status(201).json(action);
    } catch (error) {
      console.error("Create moderation action error:", error);
      res.status(400).json({ message: "Failed to execute moderation action" });
    }
  });

  // Get moderation stats
  app.get("/api/moderation/stats", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const stats = await storage.getModerationStats();
      res.json(stats);
    } catch (error) {
      console.error("Get moderation stats error:", error);
      res.status(500).json({ message: "Failed to fetch moderation stats" });
    }
  });

  // Get flagged content
  app.get("/api/moderation/flagged", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const flagged = await storage.getFlaggedContent();
      res.json(flagged);
    } catch (error) {
      console.error("Get flagged content error:", error);
      res.status(500).json({ message: "Failed to fetch flagged content" });
    }
  });

  // ============= CONTENT MANAGEMENT API ROUTES =============

  // Get all content
  app.get("/api/content", async (req: any, res) => {
    try {
      const content = await storage.getAllContent();
      res.json(content);
    } catch (error) {
      console.error("Get content error:", error);
      res.status(500).json({ message: "Failed to fetch content" });
    }
  });

  // Create content
  app.post("/api/content", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const content = await storage.createContent({
        ...req.body,
        authorId: req.user.id,
        createdAt: new Date()
      });
      res.status(201).json(content);
    } catch (error) {
      console.error("Create content error:", error);
      res.status(400).json({ message: "Failed to create content" });
    }
  });

  // Update content
  app.patch("/api/content/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const content = await storage.updateContent(req.params.id, req.body);
      if (!content) {
        return res.status(404).json({ message: "Content not found" });
      }
      res.json(content);
    } catch (error) {
      console.error("Update content error:", error);
      res.status(500).json({ message: "Failed to update content" });
    }
  });

  // Delete content
  app.delete("/api/content/:id", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      await storage.deleteContent(req.params.id);
      res.json({ message: "Content deleted successfully" });
    } catch (error) {
      console.error("Delete content error:", error);
      res.status(500).json({ message: "Failed to delete content" });
    }
  });

  // Get content stats
  app.get("/api/content/stats", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const stats = await storage.getContentStats();
      res.json(stats);
    } catch (error) {
      console.error("Get content stats error:", error);
      res.status(500).json({ message: "Failed to fetch content stats" });
    }
  });

  // ============= ANALYTICS API ROUTES =============

  // Get analytics data
  app.get("/api/analytics", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), async (req: any, res) => {
    try {
      const timeRange = req.query.timeRange || "7d";
      const analytics = await storage.getAnalyticsData(timeRange);
      res.json(analytics);
    } catch (error) {
      console.error("Get analytics error:", error);
      res.status(500).json({ message: "Failed to fetch analytics data" });
    }
  });

  // ============= INSURANCE API ROUTES =============
  app.get("/api/insurance/policies", authenticateToken, insuranceRoutes.getPolicies);
  app.post("/api/insurance/policies", authenticateToken, insuranceRoutes.purchasePolicy);
  app.post("/api/insurance/claims", authenticateToken, insuranceRoutes.submitClaim);

  // ============= IMPERSONATION API ROUTES =============
  app.get("/api/impersonation/heatmap", authenticateToken, impersonationRoutes.getHeatmap);
  app.get("/api/impersonation/alerts", authenticateToken, impersonationRoutes.getAlerts);
  app.post("/api/impersonation/report", authenticateToken, impersonationRoutes.reportImpersonation);
  app.patch("/api/impersonation/alerts/:alertId", authenticateToken, impersonationRoutes.updateAlertStatus);

  // ============= OWNERSHIP API ROUTES =============
  app.get("/api/ownership/claims", authenticateToken, ownershipRoutes.getClaims);
  app.post("/api/ownership/claims", authenticateToken, ownershipRoutes.submitClaim);
  app.get("/api/ownership/badges", authenticateToken, ownershipRoutes.getBadges);
  app.patch("/api/ownership/claims/:claimId/verify", authenticateToken, ownershipRoutes.verifyClaim);

  // ============= NEW FEATURE ROUTES =============

  // Trust scoring endpoints
  app.get("/api/trust-score/:userId", async (req, res) => {
    const { userId } = req.params;
    // Mock trust score data
    res.json({
      score: 85,
      level: "gold",
      factors: {
        successfulTransactions: 25,
        feedbackQuality: 90,
        reportHistory: 0,
        timeInCommunity: 180,
        verificationLevel: "advanced"
      },
      lastUpdated: new Date(),
      nextUpdate: new Date(Date.now() + 24 * 60 * 60 * 1000)
    });
  });

  // Live activity feed endpoint
  app.get("/api/activity-feed", async (req, res) => {
    const { filter, limit = 50 } = req.query;

    // Mock activity data
    const activities = [
      {
        id: '1',
        type: 'report',
        title: 'New Scam Report',
        description: 'User reported potential Discord scam involving crypto trading',
        severity: 'high',
        user: 'UserA#1234',
        timestamp: new Date(Date.now() - 5 * 60000),
        automated: false,
      },
      {
        id: '2',
        type: 'ai_alert',
        title: 'AI Fraud Detection',
        description: 'Suspicious pattern detected: User creating multiple accounts',
        severity: 'critical',
        user: 'SuspiciousUser#5678',
        timestamp: new Date(Date.now() - 10 * 60000),
        automated: true,
      },
    ];

    res.json(activities.slice(0, parseInt(limit as string)));
  });

  // Custom roles endpoints
  app.get("/api/custom-roles", async (req, res) => {
    // Mock roles data
    res.json([
      {
        id: 'moderator',
        name: 'Moderator',
        description: 'Standard moderation permissions',
        color: '#3B82F6',
        permissions: ['view_reports', 'handle_cases', 'ban_users'],
        userCount: 5,
        createdAt: new Date(),
      }
    ]);
  });

  app.post("/api/custom-roles", async (req, res) => {
    const { name, description, color, permissions } = req.body;

    // Mock role creation
    const newRole = {
      id: name.toLowerCase().replace(/\s+/g, '_'),
      name,
      description,
      color,
      permissions,
      userCount: 0,
      createdAt: new Date(),
    };

    res.json(newRole);
  });

  // ============= REPUTATION INSURANCE ROUTES =============
  app.get("/api/insurance/policies", authenticateToken, insuranceRoutes.getPolicies);
  app.post("/api/insurance/policies", authenticateToken, insuranceRoutes.purchasePolicy);
  app.post("/api/insurance/claims", authenticateToken, insuranceRoutes.submitClaim);

  // ============= IMPERSONATION DETECTION ROUTES =============
  app.get("/api/impersonation/heatmap", authenticateToken, impersonationRoutes.getHeatmap);
  app.get("/api/impersonation/alerts", authenticateToken, impersonationRoutes.getAlerts);
  app.post("/api/impersonation/reports", authenticateToken, impersonationRoutes.reportImpersonation);

  // ============= OWNERSHIP VERIFICATION ROUTES =============
  app.get("/api/ownership/claims", authenticateToken, ownershipRoutes.getClaims);
  app.post("/api/ownership/claims", authenticateToken, ownershipRoutes.submitClaim);
  app.get("/api/ownership/badges", authenticateToken, ownershipRoutes.getBadges);
  app.post("/api/ownership/claims/:claimId/verify", authenticateToken, requireRole(["admin", "tribunal_head", "senior_staff"]), ownershipRoutes.verifyClaim);

  const httpServer = createServer(app);
  return httpServer;
}